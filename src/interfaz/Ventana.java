/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JFrame.java to edit this template
 */
package interfaz;

import analizadores.AnalizadorSintactico;
import analizadores.Lexer;
import analizadores.ListaDeTokens;
import static analizadores.ListaDeTokens.Linea;
import analizadores.TablaDeTokens;
import analizadores.Token;
import datos.TablaErrores;
import funciones.Archivo;
import java.awt.event.KeyEvent;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.Reader;
import javax.swing.JFrame;
import javax.swing.JOptionPane;
import tabla.TablaDeSimbolos;

/**
 *
 * @author Arturo Guzmán Ávila
 * @version 1.0
 */
public class Ventana extends javax.swing.JFrame {

    private TablaErrores tablaErrores;

    private Archivo archivo;

    /**
     * Creates new form NewJFrame
     */
    public Ventana() {
        initComponents();
        actualizarLineas();
        archivo = new Archivo(this);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanelCodigo = new javax.swing.JPanel();
        jSLines = new javax.swing.JScrollPane();
        lineas = new javax.swing.JTextPane();
        jSCodigo = new javax.swing.JScrollPane();
        codigo = new javax.swing.JTextPane();
        utilidades = new javax.swing.JTabbedPane();
        jSComponentes = new javax.swing.JScrollPane();
        componentes = new javax.swing.JTextPane();
        jSTokens = new javax.swing.JScrollPane();
        tokens = new javax.swing.JTextPane();
        JPPila = new javax.swing.JPanel();
        jSPila = new javax.swing.JScrollPane();
        pila = new javax.swing.JTextPane();
        jSEstado = new javax.swing.JScrollPane();
        estado = new javax.swing.JTextPane();
        jSAccion = new javax.swing.JScrollPane();
        accion = new javax.swing.JTextPane();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextPane1 = new javax.swing.JTextPane();
        jSErrores = new javax.swing.JScrollPane();
        errores = new javax.swing.JTextPane();
        jMenuBar1 = new javax.swing.JMenuBar();
        menuArchivo = new javax.swing.JMenu();
        nuevo = new javax.swing.JMenuItem();
        abrir = new javax.swing.JMenuItem();
        guardar = new javax.swing.JMenuItem();
        guardarComo = new javax.swing.JMenuItem();
        cerrar = new javax.swing.JMenuItem();
        salir = new javax.swing.JMenuItem();
        menuAnalizador = new javax.swing.JMenu();
        opIdentificar = new javax.swing.JMenuItem();
        analiar = new javax.swing.JMenuItem();
        opPila = new javax.swing.JMenuItem();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Analiador Léxico-Sintáctico");
        setResizable(false);
        setSize(new java.awt.Dimension(1280, 720));
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent evt) {
                formWindowClosing(evt);
            }
        });

        jSLines.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);
        jSLines.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_NEVER);

        lineas.setEditable(false);
        lineas.setFont(new java.awt.Font("Consolas", 0, 18)); // NOI18N
        jSLines.setViewportView(lineas);

        jSCodigo.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);

        codigo.setFont(new java.awt.Font("Consolas", 0, 18)); // NOI18N
        codigo.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                codigoKeyReleased(evt);
            }
        });
        jSCodigo.setViewportView(codigo);

        javax.swing.GroupLayout jPanelCodigoLayout = new javax.swing.GroupLayout(jPanelCodigo);
        jPanelCodigo.setLayout(jPanelCodigoLayout);
        jPanelCodigoLayout.setHorizontalGroup(
            jPanelCodigoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelCodigoLayout.createSequentialGroup()
                .addComponent(jSLines, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jSCodigo, javax.swing.GroupLayout.DEFAULT_SIZE, 578, Short.MAX_VALUE))
        );
        jPanelCodigoLayout.setVerticalGroup(
            jPanelCodigoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jSLines)
            .addComponent(jSCodigo)
        );

        componentes.setEditable(false);
        componentes.setBorder(javax.swing.BorderFactory.createTitledBorder(javax.swing.BorderFactory.createEtchedBorder(), "Componentes"));
        componentes.setFont(new java.awt.Font("Consolas", 0, 18)); // NOI18N
        jSComponentes.setViewportView(componentes);

        utilidades.addTab("Identificador", jSComponentes);

        tokens.setEditable(false);
        tokens.setBorder(javax.swing.BorderFactory.createTitledBorder(javax.swing.BorderFactory.createEtchedBorder(), "Comopentes"));
        tokens.setFont(new java.awt.Font("Consolas", 0, 18)); // NOI18N
        jSTokens.setViewportView(tokens);

        utilidades.addTab("Componentes", jSTokens);

        pila.setEditable(false);
        pila.setBorder(javax.swing.BorderFactory.createTitledBorder(javax.swing.BorderFactory.createEtchedBorder(), "Pila"));
        pila.setFont(new java.awt.Font("Consolas", 0, 14)); // NOI18N
        jSPila.setViewportView(pila);

        estado.setEditable(false);
        estado.setBorder(javax.swing.BorderFactory.createTitledBorder(javax.swing.BorderFactory.createEtchedBorder(), "Símbolo"));
        estado.setFont(new java.awt.Font("Consolas", 0, 14)); // NOI18N
        jSEstado.setViewportView(estado);

        accion.setEditable(false);
        accion.setBorder(javax.swing.BorderFactory.createTitledBorder(javax.swing.BorderFactory.createEtchedBorder(), "Acción"));
        accion.setFont(new java.awt.Font("Consolas", 0, 14)); // NOI18N
        jSAccion.setViewportView(accion);

        javax.swing.GroupLayout JPPilaLayout = new javax.swing.GroupLayout(JPPila);
        JPPila.setLayout(JPPilaLayout);
        JPPilaLayout.setHorizontalGroup(
            JPPilaLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(JPPilaLayout.createSequentialGroup()
                .addComponent(jSPila, javax.swing.GroupLayout.PREFERRED_SIZE, 208, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jSEstado, javax.swing.GroupLayout.PREFERRED_SIZE, 208, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jSAccion, javax.swing.GroupLayout.DEFAULT_SIZE, 206, Short.MAX_VALUE))
        );
        JPPilaLayout.setVerticalGroup(
            JPPilaLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jSPila, javax.swing.GroupLayout.DEFAULT_SIZE, 321, Short.MAX_VALUE)
            .addComponent(jSEstado)
            .addComponent(jSAccion)
        );

        utilidades.addTab("Pila", JPPila);

        jTextPane1.setEditable(false);
        jTextPane1.setBorder(javax.swing.BorderFactory.createTitledBorder("Tabla de simbolos"));
        jTextPane1.setFont(new java.awt.Font("Consolas", 0, 18)); // NOI18N
        jScrollPane1.setViewportView(jTextPane1);

        utilidades.addTab("Tabla de símbolos", jScrollPane1);

        errores.setEditable(false);
        errores.setBorder(javax.swing.BorderFactory.createTitledBorder(javax.swing.BorderFactory.createEtchedBorder(), "Errores"));
        errores.setFont(new java.awt.Font("Consolas", 0, 18)); // NOI18N
        jSErrores.setViewportView(errores);

        menuArchivo.setText("Archivo");

        nuevo.setText("Nuevo");
        nuevo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                nuevoArchivo(evt);
            }
        });
        menuArchivo.add(nuevo);

        abrir.setText("Abrir");
        abrir.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                abrirArchivo(evt);
            }
        });
        menuArchivo.add(abrir);

        guardar.setText("Guardar");
        guardar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                guardarActionPerformed(evt);
            }
        });
        menuArchivo.add(guardar);

        guardarComo.setText("Guardar como...");
        guardarComo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                guardarComoActionPerformed(evt);
            }
        });
        menuArchivo.add(guardarComo);

        cerrar.setText("Cerrar archivo");
        cerrar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cerrarActionPerformed(evt);
            }
        });
        menuArchivo.add(cerrar);

        salir.setText("Salir");
        salir.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                salirActionPerformed(evt);
            }
        });
        menuArchivo.add(salir);

        jMenuBar1.add(menuArchivo);

        menuAnalizador.setText("Analizar");

        opIdentificar.setText("Identificar");
        opIdentificar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                opIdentificarActionPerformed(evt);
            }
        });
        menuAnalizador.add(opIdentificar);

        analiar.setText("Entrada");
        analiar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                analiarActionPerformed(evt);
            }
        });
        menuAnalizador.add(analiar);

        opPila.setText("Análisis sintáctico");
        opPila.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                opPilaActionPerformed(evt);
            }
        });
        menuAnalizador.add(opPila);

        jMenuBar1.add(menuAnalizador);

        setJMenuBar(jMenuBar1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(jPanelCodigo, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jSErrores)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addComponent(utilidades)
                        .addContainerGap())))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(utilidades, javax.swing.GroupLayout.PREFERRED_SIZE, 354, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jSErrores, javax.swing.GroupLayout.DEFAULT_SIZE, 337, Short.MAX_VALUE))
            .addComponent(jPanelCodigo, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * Acción del JMenuItem "Abrir".
     *
     * @param evt Objeto que lanza el evento.
     */
    private void abrirArchivo(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_abrirArchivo
        if (!archivoGuardado()) {
            switch (JOptionPane.showConfirmDialog(Ventana.this, "¿Desea guardar antes de abrir otro archivo?")) {
                case 0:
                    if (guardar()) {
                        abrir();
                    }
                    break;
                case 1:
                    abrir();
            }
        } else {
            abrir();
        }
    }//GEN-LAST:event_abrirArchivo

    /**
     * Acción del JMenuItem "Nuevo Archivo".
     *
     * @param evt Objeto que lanza el evento.
     */
    private void nuevoArchivo(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_nuevoArchivo
        nuevoArchivo();
    }//GEN-LAST:event_nuevoArchivo

    /**
     * Acción del JMenuItem "Guardar".
     *
     * @param evt Objeto que lanza el evento.
     */
    private void guardarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_guardarActionPerformed
        guardar();
    }//GEN-LAST:event_guardarActionPerformed

    /**
     * Acción del JMenuItem "Guardar cómo...".
     *
     * @param evt Objeto que lanza el evento.
     */
    private void guardarComoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_guardarComoActionPerformed
        guardarComo();
    }//GEN-LAST:event_guardarComoActionPerformed

    /**
     * Acción del JMenuItem "Cerrar".
     *
     * @param evt Objeto que lanza el evento.
     */
    private void cerrarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cerrarActionPerformed
        cerrarArchivo();
    }//GEN-LAST:event_cerrarActionPerformed

    /**
     * Determina si el archivo fue guardado antes de cerrar el programa cuando
     * preciona en la opción "salir" permite elegir entre guardar y cerrar, no
     * guardar y cerrar o no cerrar.
     *
     * @param evt Objeto que lanza el evento.
     */
    private void salirActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_salirActionPerformed
        if (!archivoGuardado()) {
            switch (JOptionPane.showConfirmDialog(Ventana.this, "¿Desea guardar antes de abrir otro archivo?")) {
                case 0:
                    if (guardar()) {
                        System.exit(0);
                    }
                    break;
                case 1:
                    System.exit(0);
                    break;
            }
        } else
            System.exit(0);
    }//GEN-LAST:event_salirActionPerformed

    /**
     * Actualiza el númro de lineas cuando se ingresa un salto de línea o se
     * presiona la tecla "Backspace". También pone el estado del archivo como no
     * guardado.
     *
     * @param evt Objeto que lanza el evento.
     */
    private void codigoKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_codigoKeyReleased
        if (evt.getKeyCode() == KeyEvent.VK_ENTER || evt.getKeyCode() == KeyEvent.VK_BACK_SPACE) {
            actualizarLineas();
        }
        archivoNoGuardado();
    }//GEN-LAST:event_codigoKeyReleased

    /**
     * Determina si el archivo fue guardado antes de cerrar el programa cuando
     * se cierra la ventna permite elegir entre guardar y cerrar, no guardar y
     * cerrar o no cerrar.
     *
     * @param evt Objeto que lanza el evento.
     */
    private void formWindowClosing(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowClosing
        if (!archivoGuardado()) {
            switch (JOptionPane.showConfirmDialog(Ventana.this, "¿Desea guardar antes de abrir otro archivo?")) {
                case -1:
                    Ventana.this.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
                    break;
                case 0:
                    if (guardar()) {
                        Ventana.this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
                    } else {
                        Ventana.this.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
                    }
                    break;
                case 1:
                    Ventana.this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
                    break;
                case 2:
                    Ventana.this.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
            }
        }
    }//GEN-LAST:event_formWindowClosing

    /**
     * Identifica los componentes presentes en el JTextPane "Codigo" y los
     * muestra en el JTextPane "componentes".
     *
     * @param evt Objeto que lanza el evento.
     */
    private void opIdentificarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_opIdentificarActionPerformed
        if (archivo.archivoSelecionado()) {
            guardar();
            identificarComponentes();
        } else if (guardarComo())
            identificarComponentes();
    }//GEN-LAST:event_opIdentificarActionPerformed

    private void analiarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_analiarActionPerformed
        identificarToken();
    }//GEN-LAST:event_analiarActionPerformed

    private void opPilaActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_opPilaActionPerformed
        analisisSintactico();
    }//GEN-LAST:event_opPilaActionPerformed

    /**
     * Cuenta el número de saltos de linea presentes en el JTextPane "codigo" y
     * lo muestra en el JTextPane "lineas".
     */
    private void actualizarLineas() {
        String aux = "";
        int numeroDeLineas = 1;
        for (char car : codigo.getText().toCharArray()) {
            if (car == '\n') {
                numeroDeLineas++;
            }
        }
        for (int i = 1; i <= numeroDeLineas; i++) {
            aux += i + (i == numeroDeLineas ? "" : "\n");
        }
        lineas.setText(aux);
    }

    /**
     * Abre un archivo con extención ".sg" y lo muestra en el JTextPane
     * "codigo".
     */
    private void abrir() {
        String contenido = archivo.abrir();
        if (contenido != null) {
            codigo.setText(contenido);
            actualizarContenido();
        }
    }

    /**
     * Guarda el contenido del archivo actualmente seleccionado. Si no hay un
     * archivo seleccionado, se despliega un JFileChooser que le permite al
     * usuario darle un nombre y elegir la ruta donde se guardará.
     *
     * @return true: si el archivo se guardó correctamente. | false: si el
     * archivo no se pudo guardar el archivo o si el usuario canceló el proceso.
     */
    private boolean guardar() {
        boolean estado = archivo.guardar(codigo.getText());
        if (estado) {
            actualizarContenido();
        }
        return estado;
    }

    /**
     * Pérmite guardar el archivo bajo un nuevo nombre.
     *
     * @return true: si el archivo se guardó correctamente. | false: si el
     * archivo no se pudo guardar el archivo o si el usuario canceló el proceso.
     */
    private boolean guardarComo() {
        if (archivo.guardarComo(codigo.getText())) {
            actualizarContenido();
            return true;
        }
        return false;
    }

    /**
     * Actualiza el título del JFrame "Ventana".
     *
     * @param titulo Título nuevo
     */
    private void actualizarTitulo(String titulo) {
        setTitle(titulo);
    }

    /**
     * Método que actualiza el estado de guardado del archivo
     */
    private void archivoNoGuardado() {
        if (getTitle().indexOf('*') == -1) {
            setTitle("*" + getTitle());
        }
    }

    /**
     * Método que determina si el archivo fue guardado
     *
     * @return true: Si el archivo está guardado | else: si el archivo no fue
     * guardado
     */
    private boolean archivoGuardado() {
        return getTitle().indexOf('*') == -1;
    }

    /**
     * Llena el JTextPane "código" con el téxto del archivo y actualiza el
     * número de líneas
     */
    private void actualizarContenido() {
        actualizarLineas();
        actualizarTitulo(archivo.nombreDelArchivo());
    }

    /**
     * Cierra el archivo actual.
     */
    private void nuevoArchivo() {
        String tmp = codigo.getText();
        codigo.setText("");
        if (guardarComo()) {
            actualizarContenido();
        } else {
            codigo.setText(tmp);
        }
    }

    /**
     * Cierra el archivo actualmente abierto y reestablece el título del JFrame
     * "Ventna".
     */
    private void cerrarArchivo() {
        codigo.setText("");
        actualizarLineas();
        setTitle("Analizador Léxico-Sintáctico");
        archivo.cerrarArrchivo();
    }

    /**
     * Identifica los componentes presentes en el JTextPane "codigo" y los
     * muestra en el JTextPane "componentes".
     */
    private void identificarComponentes() {
        try {
            String lexema, texto = "";
            int linea = 1;
            tablaErrores = new TablaErrores();
            BufferedReader lector = new BufferedReader(new FileReader(archivo.obtenerArchivo()));
            Lexer lexer = new Lexer(lector);
            ListaDeTokens token;
            while (true) {
                token = lexer.yylex();
                lexema = lexer.yytext();
                if (token == null) {
                    componentes.setText(texto);
                    errores.setText(tablaErrores.contenido());
                    return;
                }

                if (token == Linea) {
                    linea++;
                } else {
                    if (esError(token)) {
                        determinarError(token, linea, lexer.yytext());
                    }
                    texto += lexema + " es un " + token.toString() + "\n";
                }
            }
        } catch (IOException e) {
        }
    }

    /**
     * Determina si el Token que se le pasa como argumento es de tipo error.
     *
     * @param t Token a evaular.
     * @return true: el token es de tipo Error | false: el token no es de tipo
     * Error
     */
    private boolean esError(ListaDeTokens t) {
        switch (t) {
            case ERROR_Lexico:
            case ERROR_Entero:
            case ERROR_Flotante:
                return true;
        }
        return false;
    }

    /**
     * Determina el típo de error que se generó y lo guarda en la tabla de
     * errores.
     *
     * @param t Token que determina el tipo de Error.
     * @param linea Línea donde se generó, el error.
     */
    private void determinarError(ListaDeTokens t, int linea, String lexem) {
        switch (t) {
            case ERROR_Lexico:
                tablaErrores.addError(new datos.Error(linea, "Léxico", "(" + lexem + ") es un símbolo no definido."));
                return;
            case ERROR_Entero:
                tablaErrores.addError(new datos.Error(linea, "Léxico", "Los números enteros no pueden comenzar con 0."));
                return;
            case ERROR_Flotante:
                tablaErrores.addError(new datos.Error(linea, "Léxico", "Los números flotantes no pueden comenzar con 0 y tener más numeros delante antes del punto. Tampoco terminar con 0."));
                return;
        }
    }

    private String obtenerToken(ListaDeTokens t, String lexema) {
        switch (t) {
            case Linea:
            case T_dato:
            case Procedure:
            case EndProcedure:
            case Function:
            case EndFunction:
            case Return:
            case If:
            case EndIf:
            case Else:
            case Do:
            case While:
            case ReadLN:
            case Print:
            case Println:
            case Igual:
            case Op_arimetico:
            case Op_logico:
            case Op_relacional:
            case Op_Asignacion:
            case Op_incremento:
            case Op_booleano:
            case Parentesis_a:
            case Parentesis_c:
            case Program:
            case EndProgram:
            case Coma:
            case P_coma:
            case D_puntos:
                return lexema;
            case Cadena:
                return "String";
            case Identificador:
                return "id";
            case Numero:
                return "num";
            case Flotante:
                return "flt";
            case Litcad:
                return "litcad";
            case Litcar:
                return "litcar";
            default:
                return null;
        }
    }

    private void identificarToken() {
        if (archivo.archivoSelecionado()) {
            if (archivoGuardado()) {
                try {
                    boolean b1 = false, b2 = false;
                    int linea = 1;
                    String token;
                    ListaDeTokens t, ant = null;
                    TablaDeTokens tablaTokens = new TablaDeTokens();
                    tablaErrores = new TablaErrores();
                    Reader lector = new BufferedReader(new FileReader(archivo.obtenerArchivo()));
                    Lexer lexer = new Lexer(lector);
                    while (true) {
                        t = lexer.yylex();
                        token = lexer.yytext();
                        if (t == null) {
                            tablaTokens.addToken(new Token(linea, null, "$", null));
                            tokens.setText(tablaTokens.contenido());
                            errores.setText(tablaErrores.contenido());
                            return;
                        } else {
                            if (esError(t)) {
                                determinarError(t, linea, token);
                            } else if (t == Linea) {
                                linea++;
                            } else {
                                tablaTokens.addToken(nuevoToken(linea, token, t, ant));
                                ant = t;
                            }
                        }
                    }
                } catch (IOException e) {
                }
            } else {
                guardar();
                identificarToken();
            }
        } else {
            if (guardarComo()) {
                identificarToken();
            }
        }
    }

    private boolean esFuncion(ListaDeTokens t) {
        if (t == ListaDeTokens.Function) {
            return true;
        }
        return false;
    }

    private boolean esProceso(ListaDeTokens t) {
        if (t == ListaDeTokens.Procedure) {
            return true;
        }
        return false;
    }

    private Token nuevoToken(int linea, String token, ListaDeTokens t, ListaDeTokens ant) {
        boolean ban = t == ListaDeTokens.Identificador;
        if (ant == ListaDeTokens.Function && ban) {
            return new Token(linea, null, "idf", token);
        }
        if (ant == ListaDeTokens.Procedure && ban) {
            return new Token(linea, null, "idp", token);
        }
        return new Token(linea, null, obtenerToken(t, token), token);
    }

    private void analisisSintactico() {
        if (archivo.archivoSelecionado()) {
            if (archivoGuardado()) {
                try {
                    int linea = 1;
                    String lexme;
                    ListaDeTokens lt, ant = null;
                    Token t;
                    tablaErrores = new TablaErrores();
                    Reader lector = new BufferedReader(new FileReader(archivo.obtenerArchivo()));
                    Lexer lexer = new Lexer(lector);
                    AnalizadorSintactico analizador = new AnalizadorSintactico();
                    while (true) {
                        lt = lexer.yylex();
                        lexme = lexer.yytext();

                        if (analizador.getError() != null) {
                            errores.setText(analizador.getError());
                            new Analisis(this, false, analizador.obtenerTabla()).setVisible(true);
                            
                            return;
                        }

                        if (lt == null) {
                            analizador.analisisSintactico(new Token(linea, null, "$", null));
                            new Analisis(this, false, analizador.obtenerTabla()).setVisible(true);
                            if (analizador.getError() != null) {
                                errores.setText(analizador.getError());
                            }
                            return;
                        } else {
                            if (esError(lt)) {
                                determinarError(lt, linea, lexme);
                            } else if (lt == Linea) {
                                linea++;
                            } else {
                                t = nuevoToken(linea, lexme, lt, ant);
                                analizador.analisisSintactico(t);
                                ant = lt;
                            }
                        }
                    }
                } catch (IOException e) {
                }
            } else {
                guardar();
                analisisSintactico();
            }
        } else {
            if (guardarComo()) {
                analisisSintactico();
            }
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        new Ventana().setVisible(true);
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel JPPila;
    private javax.swing.JMenuItem abrir;
    private javax.swing.JTextPane accion;
    private javax.swing.JMenuItem analiar;
    private javax.swing.JMenuItem cerrar;
    private javax.swing.JTextPane codigo;
    private javax.swing.JTextPane componentes;
    private javax.swing.JTextPane errores;
    private javax.swing.JTextPane estado;
    private javax.swing.JMenuItem guardar;
    private javax.swing.JMenuItem guardarComo;
    private javax.swing.JMenuBar jMenuBar1;
    private javax.swing.JPanel jPanelCodigo;
    private javax.swing.JScrollPane jSAccion;
    private javax.swing.JScrollPane jSCodigo;
    private javax.swing.JScrollPane jSComponentes;
    private javax.swing.JScrollPane jSErrores;
    private javax.swing.JScrollPane jSEstado;
    private javax.swing.JScrollPane jSLines;
    private javax.swing.JScrollPane jSPila;
    private javax.swing.JScrollPane jSTokens;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTextPane jTextPane1;
    private javax.swing.JTextPane lineas;
    private javax.swing.JMenu menuAnalizador;
    private javax.swing.JMenu menuArchivo;
    private javax.swing.JMenuItem nuevo;
    private javax.swing.JMenuItem opIdentificar;
    private javax.swing.JMenuItem opPila;
    private javax.swing.JTextPane pila;
    private javax.swing.JMenuItem salir;
    private javax.swing.JTextPane tokens;
    private javax.swing.JTabbedPane utilidades;
    // End of variables declaration//GEN-END:variables
}
